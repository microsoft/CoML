[
  {
    "variables": {},
    "codes": [
      "import pandas as pd"
    ],
    "request": "Write a function `def capital_gainloss(stocks: pd.DataFrame) -> pd.DataFrame`.\n\n`stocks` is a DataFrame with the following columns:\n- stock_name: str\n- operation: str\n- operation_day: int\n- price: int\nEach record indicates that the stock which has `stock_name` had an operation on the day `operation_day` with the price. The `operation` must be one of `Sell`, `Buy`. It is guaranteed that each 'Sell' operation for a stock has a corresponding 'Buy' operation in a previous day. It is also guaranteed that each 'Buy' operation for a stock has a corresponding 'Sell' operation in an upcoming day.\n\nThe function should report the **Capital gain/loss** for each stock. The **Capital gain/loss** of a stock is the total gain or loss after buying and selling the stock one or many times. Return the result table in **any order**.\n\nThe result format is in the following example.\n\nExample input:\n```\nstocks:\n+---------------+-----------+---------------+--------+\n| stock_name    | operation | operation_day | price  |\n+---------------+-----------+---------------+--------+\n| Leetcode      | Buy       | 1             | 1000   |\n| Corona Masks  | Buy       | 2             | 10     |\n| Leetcode      | Sell      | 5             | 9000   |\n| Handbags      | Buy       | 17            | 30000  |\n| Corona Masks  | Sell      | 3             | 1010   |\n| Corona Masks  | Buy       | 4             | 1000   |\n| Corona Masks  | Sell      | 5             | 500    |\n| Corona Masks  | Buy       | 6             | 1000   |\n| Handbags      | Sell      | 29            | 7000   |\n| Corona Masks  | Sell      | 10            | 10000  |\n+---------------+-----------+---------------+--------+\n```\n\nExample output:\n```\n+---------------+-------------------+\n| stock_name    | capital_gain_loss |\n+---------------+-------------------+\n| Corona Masks  | 9500              |\n| Leetcode      | 8000              |\n| Handbags      | -23000            |\n+---------------+-------------------+\n```\n\nExample explanation:\n- Leetcode stock was bought at day 1 for 1000$ and was sold at day 5 for 9000$. Capital gain = 9000 - 1000 = 8000$.\n- Handbags stock was bought at day 17 for 30000$ and was sold at day 29 for 7000$. Capital loss = 7000 - 30000 = -23000$.\n- Corona Masks stock was bought at day 1 for 10$ and was sold at day 3 for 1010$. It was bought again at day 4 for 1000$ and was sold at day 5 for 500$. At last, it was bought at day 6 for 1000$ and was sold at day 10 for 10000$. Capital gain/loss is the sum of capital gains/losses for each ('Buy' --> 'Sell') operation = (1010 - 10) + (500 - 1000) + (10000 - 1000) = 1000 - 500 + 9000 = 9500$.\n",
    "answer": "def capital_gainloss(stocks: pd.DataFrame) -> pd.DataFrame:\n    # Create a copy of the dataframe to avoid modifying the original one\n    df = stocks.copy()\n\n    # Calculate the capital gain/loss for each stock\n    df[\"price\"] = df.apply(\n        lambda x: -x[\"price\"] if x[\"operation\"] == \"Buy\" else x[\"price\"], axis=1\n    )\n    result = df.groupby(\"stock_name\")[\"price\"].sum().reset_index()\n    result.columns = [\"stock_name\", \"capital_gain_loss\"]\n\n    return result"
  },
  {
    "variables": {},
    "codes": [
      "import pandas as pd"
    ],
    "request": "Write a function `def consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame`.\n\n`logs` is a DataFrame with the following columns:\n- id: int\n- num: int\n`id` is an autoincrement column and serves as the primary key.\n\nThe function should find all numbers that appear at least three times consecutively and return the result in a DataFrame with a single column `ConsecutiveNums`. The result should be returned in **any order**.\n\nExample input:\n```\nlogs:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n```\n\nExample output:\n```\n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n```\n\nExample explanation:\n- 1 is the only number that appears consecutively for at least three times.\n",
    "answer": "def consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\n    # Create a new column to identify consecutive numbers\n    logs[\"shifted_num\"] = logs[\"num\"].shift(2)\n    logs[\"is_consecutive\"] = logs[\"num\"].eq(logs[\"num\"].shift()) & logs[\"num\"].eq(logs[\"shifted_num\"])\n\n    # Filter out the rows where numbers are not consecutive\n    consecutive = logs[logs[\"is_consecutive\"]]\n\n    # Get the unique numbers that are consecutive\n    result = pd.DataFrame(consecutive[\"num\"].unique(), columns=[\"ConsecutiveNums\"])\n\n    return result"
  },
  {
    "variables": {},
    "codes": [
      "import pandas as pd"
    ],
    "request": "Write a function `def employee_bonus(employee: pd.DataFrame, bonus: pd.DataFrame) -> pd.DataFrame`.\n\n`employee` is a DataFrame with the following columns:\n- empId: int\n- name: str\n- supervisor: int\n- salary: int\nEach record indicates the name and the ID of an employee in addition to their salary and the id of their manager.\n\n`bonus` is a DataFrame with the following columns:\n- empId: int\n- bonus: int\nEach record contains the id of an employee and their respective bonus.\n\nThe function should report the name and bonus amount of each employee with a bonus **less than** `1000`.\n\nReturn the result table in **any order**.\n\nThe result format is in the following example.\n\nExample input:\n```\nemployee:\n+-------+--------+------------+--------+\n| empId | name   | supervisor | salary |\n+-------+--------+------------+--------+\n| 3     | Brad   | null       | 4000   |\n| 1     | John   | 3          | 1000   |\n| 2     | Dan    | 3          | 2000   |\n| 4     | Thomas | 3          | 4000   |\n+-------+--------+------------+--------+\nbonus:\n+-------+-------+\n| empId | bonus |\n+-------+-------+\n| 2     | 500   |\n| 4     | 2000  |\n+-------+-------+\n```\n\nExample output:\n```\n+------+-------+\n| name | bonus |\n+------+-------+\n| Brad | null  |\n| John | null  |\n| Dan  | 500   |\n+------+-------+\n```\n",
    "answer": "def employee_bonus(employee: pd.DataFrame, bonus: pd.DataFrame) -> pd.DataFrame:\n    # Merge the employee and bonus dataframes on empId.\n    merged_df = pd.merge(employee[[\"empId\", \"name\"]], bonus, on=\"empId\", how=\"left\")\n\n    # Filter out the employees with bonus >= 1000 or without a bonus.\n    result_df = merged_df[merged_df[\"bonus\"].isna() | (merged_df[\"bonus\"] < 1000)]\n\n    # Select only the name and bonus columns for the final output.\n    return result_df[[\"name\", \"bonus\"]]"
  },
  {
    "variables": {},
    "codes": [
      "import pandas as pd"
    ],
    "request": "Write a function `def price_at_given_date(products: pd.DataFrame) -> pd.DataFrame`.\n\n`products` is a DataFrame with the following columns:\n- product_id: int\n- new_price: int\n- change_date: datetime\nEach record indicates that the price of some product was changed to a new price at some date. Assume the price of all products before any change is `10`.\n\nThe function should return the prices of all products on `2019-08-16`. Return the result table in **any order**.\n\nThe result format is in the following example.\n\nExample input:\n```\nproducts:\n+------------+-----------+-------------+\n| product_id | new_price | change_date |\n+------------+-----------+-------------+\n| 1          | 20        | 2019-08-14  |\n| 2          | 50        | 2019-08-14  |\n| 1          | 30        | 2019-08-15  |\n| 1          | 35        | 2019-08-16  |\n| 2          | 65        | 2019-08-17  |\n| 3          | 20        | 2019-08-18  |\n+------------+-----------+-------------+\n```\n\nExample output:\n```\n+------------+-------+\n| product_id | price |\n+------------+-------+\n| 2          | 50    |\n| 1          | 35    |\n| 3          | 10    |\n+------------+-------+\n```\n",
    "answer": "def price_at_given_date(products: pd.DataFrame) -> pd.DataFrame:\n    # Filter out the prices that are set after the given date\n    filtered_products = products[products[\"change_date\"] <= \"2019-08-16\"]\n\n    # Sort by product_id and change_date to get the latest price before or on the given date\n    sorted_products = filtered_products.sort_values(\n        by=[\"product_id\", \"change_date\"], ascending=[True, False]\n    )\n\n    # Drop duplicates to keep only the latest price for each product\n    latest_prices = sorted_products.drop_duplicates(subset=[\"product_id\"])\n\n    # If a product has no price change before the given date, its price is assumed to be 10\n    all_products = pd.DataFrame({\"product_id\": products[\"product_id\"].unique()})\n    result = pd.merge(\n        all_products,\n        latest_prices[[\"product_id\", \"new_price\"]],\n        on=\"product_id\",\n        how=\"left\",\n    )\n    result[\"price\"] = result[\"new_price\"].fillna(10).astype(int)\n\n    # Select the required columns and return the result\n    return result[[\"product_id\", \"price\"]]"
  },
  {
    "variables": {},
    "codes": [
      "import pandas as pd"
    ],
    "request": "Write a function `def latest_login(logins: pd.DataFrame) -> pd.DataFrame`.\n\n`logins` is a DataFrame with the following columns:\n- user_id: int\n- time_stamp: datetime\nEach record contains information about the login time for the user with ID `user_id`. The combination of `user_id` and `time_stamp` is unique for this table.\n\nThe function should report the **latest** login for all users in the year `2020`. Do **not** include the users who did not login in `2020`. Return the result table **in any order**.\n\nThe result format is in the following example.\n\nExample input:\n```\nlogins:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 6       | 2021-04-21 14:06:06 |\n| 6       | 2019-03-07 00:18:15 |\n| 8       | 2020-02-01 05:10:53 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n| 2       | 2019-08-25 07:59:08 |\n| 14      | 2019-07-14 09:00:00 |\n| 14      | 2021-01-06 11:59:59 |\n+---------+---------------------+\n```\n\nExample output:\n```\n+---------+---------------------+\n| user_id | last_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n+---------+---------------------+\n```\n\nExample explanation:\n- User 6 logged into their account 3 times but only once in 2020, so we include this login in the result table.\n- User 8 logged into their account 2 times in 2020, once in February and once in December. We include only the latest one (December) in the result table.\n- User 2 logged into their account 2 times but only once in 2020, so we include this login in the result table.\n- User 14 did not login in 2020, so we do not include them in the result table.\n",
    "answer": "def latest_login(logins: pd.DataFrame) -> pd.DataFrame:\n    # Filter logins for the year 2020\n    logins_2020 = logins[logins[\"time_stamp\"].dt.year == 2020]\n\n    # Find the latest login for each user in 2020\n    latest_logins = logins_2020.groupby(\"user_id\")[\"time_stamp\"].max().reset_index()\n\n    # Rename the column for the output\n    latest_logins = latest_logins.rename(columns={\"time_stamp\": \"last_stamp\"})\n\n    return latest_logins"
  }
]